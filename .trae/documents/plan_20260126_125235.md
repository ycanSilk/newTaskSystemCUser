# 用户状态管理合并方案

## 一、合并可行性分析

### 1. 功能重合度
- 两个文件都管理用户登录状态
- 都有API调用获取用户信息
- 都有登录页面判断逻辑

### 2. 合并优势
- **减少代码冗余**：避免重复的登录页面判断和状态管理
- **统一API调用**：集中管理所有用户相关的API请求
- **简化组件调用**：只需要导入一个`useUserStore`
- **降低维护成本**：修改逻辑时只需要修改一个文件
- **消除依赖关系**：不再需要`useUser`依赖`userStore`

### 3. 技术可行性
- Zustand支持异步操作和中间件
- 可以在store中实现防抖和页面可见性监听
- 可以保持现有API不变，确保向后兼容

## 二、合并方案

### 1. 保留文件
- **保留**：`src/store/userStore.ts` - 作为唯一的用户状态管理文件
- **废弃**：`src/hooks/useUser.ts` - 功能合并后变为无用文件

### 2. 功能整合

#### 2.1 核心功能迁移
将`useUser.ts`中的核心功能迁移到`userStore.ts`：

| 功能 | 原文件 | 迁移目标 |
|------|--------|----------|
| 校验Token (`/api/auth/checkToken`) | `useUser.ts` | `userStore.fetchUser` |
| 获取未读消息数 (`/api/notifications/getNotificationsList`) | `useUser.ts` | `userStore.fetchUser` |
| 防抖机制 | `useUser.ts` | `userStore` 内部实现 |
| 页面可见性监听 | `useUser.ts` | `userStore` 内部实现 |

#### 2.2 状态增强
在`userStore`中增强状态管理：

```javascript
interface UserState {
  // 原有状态
  currentUser: User | null;
  isLoading: boolean;
  error: string | null;
  
  // 新增状态
  unread_count: number; // 未读消息数量
  lastRequestTime: number; // 上次请求时间，用于防抖
}
```

#### 2.3 方法整合
重构`fetchUser`方法，整合所有API调用：

```javascript
fetchUser: async (forceRefresh = false) => {
  // 防抖逻辑
  const now = Date.now();
  if (!forceRefresh && now - get().lastRequestTime < 1000) {
    return;
  }
  
  // 其他条件判断（已有用户信息、登录页面、无cookie）
  
  // 调用`/api/auth/checkToken`验证登录状态
  // 调用`/api/users/getUserInfo`获取用户信息
  // 调用`/api/notifications/getNotificationsList`获取未读消息数
  
  // 更新状态
  set({ 
    currentUser: userData,
    unread_count: unreadCount,
    lastRequestTime: now,
    // 其他状态更新
  });
}
```

#### 2.4 页面可见性监听
在`userStore`中实现页面可见性监听：

```javascript
// 在store创建时初始化
if (typeof window !== 'undefined') {
  const handleVisibilityChange = () => {
    if (document.visibilityState === 'visible') {
      // 调用fetchUser刷新用户信息
      get().fetchUser();
    }
  };
  
  document.addEventListener('visibilitychange', handleVisibilityChange);
  
  // 组件卸载时清除监听（可以通过返回清理函数实现）
}
```

### 3. 组件调用简化
合并后，组件只需要导入`useUserStore`即可：

```javascript
import { useUserStore } from '@/store/userStore';

const { currentUser, fetchUser, unread_count } = useUserStore();
```

## 三、实现步骤

1. **修改`userStore.ts`**：
   - 增强状态定义，添加`unread_count`和`lastRequestTime`
   - 重构`fetchUser`方法，整合所有API调用
   - 实现防抖机制
   - 实现页面可见性监听

2. **更新组件引用**：
   - 将所有使用`useUser`的组件改为直接使用`useUserStore`
   - 移除对`useUser`的导入

3. **测试验证**：
   - 验证登录状态正常获取
   - 验证未读消息数正常更新
   - 验证防抖机制有效
   - 验证页面可见性监听正常工作

4. **清理无用文件**：
   - 删除`src/hooks/useUser.ts`
   - 清理相关导入和引用

## 四、预期效果

1. **代码结构优化**：
   - 减少了一个无用文件
   - 统一了用户状态管理逻辑
   - 降低了代码冗余

2. **功能增强**：
   - 保留了原有所有功能
   - 整合了`useUser`中的高级功能
   - 提供了更全面的用户状态管理

3. **使用简化**：
   - 组件只需要导入一个`useUserStore`
   - 不再需要记忆两个不同的导入路径
   - API调用更加统一

4. **维护便捷**：
   - 修改用户状态逻辑时只需要修改一个文件
   - 降低了后续维护成本
   - 代码逻辑更加清晰

## 五、风险评估

1. **兼容性风险**：
   - 需要确保所有使用`useUser`的组件都更新为使用`useUserStore`
   - 可以考虑保留`useUser`作为`useUserStore`的别名，确保向后兼容

2. **性能风险**：
   - 合并后API调用次数可能增加
   - 但通过防抖机制可以避免频繁调用
   - 整体性能不会受到明显影响

3. **测试风险**：
   - 需要全面测试所有用户相关功能
   - 确保合并后不会引入新的bug

## 六、结论

用户的想法是**可行的**，将`useUser.ts`的功能合并到`userStore.ts`中可以带来代码结构优化、功能增强、使用简化和维护便捷等好处。通过合理的实现方案，可以确保合并过程平滑进行，不会对现有功能造成影响。